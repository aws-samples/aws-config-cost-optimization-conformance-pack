AWSTemplateFormatVersion: "2010-09-09"

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Settings
        Parameters:
          - DeployingInDelegatedAdminAccount
          - ConfigRoleExistingNamePattern
    ParameterLabels:
      DeployingInDelegatedAdminAccount:
        default: Deploying In Delegated Admin Account?
      ConfigRoleExistingNamePattern:
        default: Supply the existing naming pattern for the IAM roles currently used for AWS Config.

Parameters:
  DeployingInDelegatedAdminAccount:
    Type: String
    AllowedValues:
      - "True"
      - "False"

  ConfigRoleExistingNamePattern:
    Type: String

Conditions:
  DelegatedAdmin: !Equals
    - !Ref DeployingInDelegatedAdminAccount
    - "True"

Transform: AWS::Serverless-2016-10-31

Resources:
  GetOrgDetailsFunction:
    Type: AWS::Serverless::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: VPC not required.
          - id: W92
            reason: Reserved Concurrency not required.
          - id: W11
            reason: Resource level permissions not possible on this API.
    Properties:
      Runtime: python3.10
      Handler: index.handler
      Architectures:
        - arm64
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - organizations:ListRoots
                - organizations:DescribeOrganization
              Resource: '*'
      InlineCode: |-
        import json


        import boto3
        import cfnresponse


        org = boto3.client("organizations")




        def handler(event, context):

            # pylint: disable=unused-argument
            print(json.dumps(event))
            try:
                if event["RequestType"] in ["Create", "Update"]:
                    response = {
                        "MasterAccountId": org.describe_organization()["Organization"][
                            "MasterAccountId"
                        ]
                    }
                    cfnresponse.send(
                        event,
                        context,
                        cfnresponse.SUCCESS,
                        response,
                        org.list_roots()["Roots"][0]["Id"],
                    )
                elif event["RequestType"] == "Delete":
                    cfnresponse.send(event, context, cfnresponse.SUCCESS, None, "RootId")
            except Exception:
                cfnresponse.send(event, context, cfnresponse.FAILED, None, "RootId")
                raise

  OrgDetails:
    Type: Custom::OrganizationRootId
    Properties:
      ServiceToken: !GetAtt GetOrgDetailsFunction.Arn

  CustomConfigFunction:
    Type: AWS::Serverless::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: VPC not required.
          - id: W92
            reason: Reserved Concurrency not required.
          - id: W11
            reason: Resource level permissions not possible.
    Properties:
      Runtime: python3.10
      Handler: index.lambda_handler
      Architectures:
        - arm64
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - sts:AssumeRole
              Resource: !Sub arn:${AWS::Partition}:iam::*:role/Custom_AWSServiceRoleForConfig-${AWS::Region}
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - ce:GetRightsizingRecommendation
              Resource: '*'
      InlineCode: |-
        import datetime
        import json
        import sys


        import boto3
        import botocore


        try:
            import liblogging
        except ImportError:
            pass


        ##############
        # Parameters #
        ##############

        # Define the default resource to report to Config Rules
        DEFAULT_RESOURCE_TYPE = "AWS::::Account"


        # Set to True to get the lambda to assume the Role attached on the Config Service (useful for cross-account).
        ASSUME_ROLE_MODE = True


        # Other parameters (no change needed)
        CONFIG_ROLE_TIMEOUT_SECONDS = 900


        #############
        # Main Code #
        #############



        def evaluate_compliance(event, configuration_item, valid_rule_parameters):
            """Form the evaluation(s) to be return to Config Rules


            Return either:
            None -- when no result needs to be displayed
            a string -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
            a dictionary -- the evaluation dictionary, usually built by build_evaluation_from_config_item()
            a list of dictionary -- a list of evaluation dictionary , usually built by build_evaluation()


            Keyword arguments:
            event -- the event variable given in the lambda handler
            configuration_item -- the configurationItem dictionary in the invokingEvent
            valid_rule_parameters -- the output of the evaluate_parameters() representing validated parameters of the Config Rule


            Advanced Notes:
            1 -- if a resource is deleted and generate a configuration change with ResourceDeleted status, the Boilerplate code will put a NOT_APPLICABLE on this resource automatically.
            2 -- if a None or a list of dictionary is returned, the old evaluation(s) which are not returned in the new evaluation list are returned as NOT_APPLICABLE by the Boilerplate code
            3 -- if None or an empty string, list or dict is returned, the Boilerplate code will put a "shadow" evaluation to feedback that the evaluation took place properly
            """


            ###############################
            # Add your custom logic here. #
            ###############################
            rule_eval = globals()[
                f"{valid_rule_parameters['customFunctionPrefix']}_evaluate_compliance"
            ]
            return rule_eval(configuration_item, valid_rule_parameters)




        def evaluate_parameters(rule_parameters):
            """Evaluate the rule parameters dictionary validity. Raise a ValueError for invalid parameters.


            Return:
            anything suitable for the evaluate_compliance()


            Keyword arguments:
            rule_parameters -- the Key/Value dictionary of the Config Rules parameters
            """
            valid_rule_parameters = rule_parameters
            return valid_rule_parameters




        ####################
        # Helper Functions #
        ####################



        # Build an error to be displayed in the logs when the parameter is invalid.
        def build_parameters_value_error_response(ex):
            """Return an error dictionary when the evaluate_parameters() raises a ValueError.


            Keyword arguments:
            ex -- Exception text
            """
            return build_error_response(
                internal_error_message="Parameter value is invalid",
                internal_error_details="An ValueError was raised during the validation of the Parameter value",
                customer_error_code="InvalidParameterValueException",
                customer_error_message=str(ex),
            )




        # This gets the client after assuming the Config service role
        # either in the same AWS account or cross-account.
        def get_client(service, event, region=None):
            """Return the service boto client. It should be used instead of directly calling the client.


            Keyword arguments:
            service -- the service name used for calling the boto.client()
            event -- the event variable given in the lambda handler
            region -- the region where the client is called (default: None)
            """
            if not ASSUME_ROLE_MODE:
                return boto3.client(service, region)
            credentials = get_assume_role_credentials(get_execution_role_arn(event), region)
            return boto3.client(
                service,
                aws_access_key_id=credentials["AccessKeyId"],
                aws_secret_access_key=credentials["SecretAccessKey"],
                aws_session_token=credentials["SessionToken"],
                region_name=region,
            )




        # This generate an evaluation for config
        def build_evaluation(
            resource_id,
            compliance_type,
            event,
            resource_type=DEFAULT_RESOURCE_TYPE,
            annotation=None,
        ):
            """Form an evaluation as a dictionary. Usually suited to report on scheduled rules.


            Keyword arguments:
            resource_id -- the unique id of the resource to report
            compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
            event -- the event variable given in the lambda handler
            resource_type -- the CloudFormation resource type (or AWS::::Account) to report on the rule (default DEFAULT_RESOURCE_TYPE)
            annotation -- an annotation to be added to the evaluation (default None). It will be truncated to 255 if longer.
            """
            eval_cc = {}
            if annotation:
                eval_cc["Annotation"] = build_annotation(annotation)
            eval_cc["ComplianceResourceType"] = resource_type
            eval_cc["ComplianceResourceId"] = resource_id
            eval_cc["ComplianceType"] = compliance_type
            eval_cc["OrderingTimestamp"] = str(
                json.loads(event["invokingEvent"])["notificationCreationTime"]
            )
            return eval_cc




        def build_evaluation_from_config_item(
            configuration_item, compliance_type, annotation=None
        ):
            """Form an evaluation as a dictionary. Usually suited to report on configuration change rules.


            Keyword arguments:
            configuration_item -- the configurationItem dictionary in the invokingEvent
            compliance_type -- either COMPLIANT, NON_COMPLIANT or NOT_APPLICABLE
            annotation -- an annotation to be added to the evaluation (default None). It will be truncated to 255 if longer.
            """
            eval_ci = {}
            if annotation:
                eval_ci["Annotation"] = build_annotation(annotation)
            eval_ci["ComplianceResourceType"] = configuration_item["resourceType"]
            eval_ci["ComplianceResourceId"] = configuration_item["resourceId"]
            eval_ci["ComplianceType"] = compliance_type
            eval_ci["OrderingTimestamp"] = configuration_item["configurationItemCaptureTime"]
            return eval_ci




        ####################
        # Boilerplate Code #
        ####################



        # Get execution role for Lambda function
        def get_execution_role_arn(event):
            role_arn = None
            if "ruleParameters" in event:
                rule_params = json.loads(event["ruleParameters"])
                role_name = rule_params.get("ExecutionRoleName")
                if role_name:
                    execution_role_prefix = event["executionRoleArn"].split("/")[0]
                    role_arn = f"{execution_role_prefix}/{role_name}"


            if not role_arn:
                role_arn = event["executionRoleArn"]


            return role_arn




        # Build annotation within Service constraints
        def build_annotation(annotation_string):
            if len(annotation_string) > 256:
                return annotation_string[:244] + " [truncated]"
            return annotation_string




        # Helper function used to validate input
        def check_defined(reference, reference_name):
            if not reference:

                # pylint: disable=broad-exception-raised
                raise Exception("Error: ", reference_name, "is not defined")
            return reference




        # Check whether the message is OversizedConfigurationItemChangeNotification or not
        def is_oversized_changed_notification(message_type):
            check_defined(message_type, "messageType")
            return message_type == "OversizedConfigurationItemChangeNotification"




        # Check whether the message is a ScheduledNotification or not.
        def is_scheduled_notification(message_type):
            check_defined(message_type, "messageType")
            return message_type == "ScheduledNotification"




        # Get configurationItem using getResourceConfigHistory API
        # in case of OversizedConfigurationItemChangeNotification
        def get_configuration(resource_type, resource_id, configuration_capture_time):
            result = AWS_CONFIG_CLIENT.get_resource_config_history(
                resourceType=resource_type,
                resourceId=resource_id,
                laterTime=configuration_capture_time,
                limit=1,
            )
            configuration_item = result["configurationItems"][0]
            return convert_api_configuration(configuration_item)




        # Convert from the API model to the original invocation model
        def convert_api_configuration(configuration_item):
            for k, v in configuration_item.items():
                if isinstance(v, datetime.datetime):
                    configuration_item[k] = str(v)
            configuration_item["awsAccountId"] = configuration_item["accountId"]
            configuration_item["ARN"] = configuration_item["arn"]
            configuration_item["configurationStateMd5Hash"] = configuration_item[
                "configurationItemMD5Hash"
            ]
            configuration_item["configurationItemVersion"] = configuration_item["version"]
            configuration_item["configuration"] = json.loads(
                configuration_item["configuration"]
            )
            if "relationships" in configuration_item:
                for i in range(len(configuration_item["relationships"])):
                    configuration_item["relationships"][i]["name"] = configuration_item[
                        "relationships"
                    ][i]["relationshipName"]
            return configuration_item




        # Based on the type of message get the configuration item
        # either from configurationItem in the invoking event
        # or using the getResourceConfigHistiry API in getConfiguration function.
        def get_configuration_item(invoking_event):
            check_defined(invoking_event, "invokingEvent")
            if is_oversized_changed_notification(invoking_event["messageType"]):
                configuration_item_summary = check_defined(
                    invoking_event["configurationItemSummary"], "configurationItemSummary"
                )
                return get_configuration(
                    configuration_item_summary["resourceType"],
                    configuration_item_summary["resourceId"],
                    configuration_item_summary["configurationItemCaptureTime"],
                )
            if is_scheduled_notification(invoking_event["messageType"]):
                return None
            return check_defined(invoking_event["configurationItem"], "configurationItem")




        # Check whether the resource has been deleted. If it has, then the evaluation is unnecessary.
        def is_applicable(configuration_item, event):
            try:
                check_defined(configuration_item, "configurationItem")
                check_defined(event, "event")

            # pylint: disable=bare-except
            except:
                return True
            status = configuration_item["configurationItemStatus"]
            event_left_scope = event["eventLeftScope"]
            if status == "ResourceDeleted":
                print("Resource Deleted, setting Compliance Status to NOT_APPLICABLE.")


            return status in ("OK", "ResourceDiscovered") and not event_left_scope




        def get_assume_role_credentials(role_arn, region=None):
            sts_client = boto3.client("sts", region)
            try:
                assume_role_response = sts_client.assume_role(
                    RoleArn=role_arn,
                    RoleSessionName="configLambdaExecution",
                    DurationSeconds=CONFIG_ROLE_TIMEOUT_SECONDS,
                )
                if "liblogging" in sys.modules:
                    liblogging.logSession(role_arn, assume_role_response)
                return assume_role_response["Credentials"]
            except botocore.exceptions.ClientError as ex:

                # Scrub error message for any internal account info leaks
                print(str(ex))
                if "AccessDenied" in ex.response["Error"]["Code"]:
                    ex.response["Error"][
                        "Message"
                    ] = "AWS Config does not have permission to assume the IAM role."
                else:
                    ex.response["Error"]["Message"] = "InternalError"
                    ex.response["Error"]["Code"] = "InternalError"
                raise ex




        # This removes older evaluation (usually useful for periodic rule not reporting on AWS::::Account).
        def clean_up_old_evaluations(latest_evaluations, event):
            cleaned_evaluations = []


            old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                ConfigRuleName=event["configRuleName"],
                ComplianceTypes=["COMPLIANT", "NON_COMPLIANT"],
                Limit=100,
            )


            old_eval_list = []


            while True:
                for old_result in old_eval["EvaluationResults"]:
                    old_eval_list.append(old_result)
                if "NextToken" in old_eval:
                    next_token = old_eval["NextToken"]
                    old_eval = AWS_CONFIG_CLIENT.get_compliance_details_by_config_rule(
                        ConfigRuleName=event["configRuleName"],
                        ComplianceTypes=["COMPLIANT", "NON_COMPLIANT"],
                        Limit=100,
                        NextToken=next_token,
                    )
                else:
                    break


            for old_eval in old_eval_list:
                old_resource_id = old_eval["EvaluationResultIdentifier"][
                    "EvaluationResultQualifier"
                ]["ResourceId"]
                newer_founded = False
                for latest_eval in latest_evaluations:
                    if old_resource_id == latest_eval["ComplianceResourceId"]:
                        newer_founded = True
                if not newer_founded:
                    cleaned_evaluations.append(
                        build_evaluation(old_resource_id, "NOT_APPLICABLE", event)
                    )


            return cleaned_evaluations + latest_evaluations




        def lambda_handler(event, context):
            print(json.dumps(event))

            # pylint: disable=unused-argument
            if "liblogging" in sys.modules:
                liblogging.logEvent(event)


            # pylint: disable=global-variable-undefined
            global AWS_CONFIG_CLIENT


            # print(event)
            check_defined(event, "event")
            invoking_event = json.loads(event["invokingEvent"])
            rule_parameters = {}
            if "ruleParameters" in event:
                rule_parameters = json.loads(event["ruleParameters"])


            try:
                valid_rule_parameters = evaluate_parameters(rule_parameters)
            except ValueError as ex:
                return build_parameters_value_error_response(ex)


            try:
                AWS_CONFIG_CLIENT = get_client("config", event)
                if invoking_event["messageType"] in [
                    "ConfigurationItemChangeNotification",
                    "ScheduledNotification",
                    "OversizedConfigurationItemChangeNotification",
                ]:
                    configuration_item = get_configuration_item(invoking_event)
                    if is_applicable(configuration_item, event):
                        compliance_result = evaluate_compliance(
                            event, configuration_item, valid_rule_parameters
                        )
                    else:
                        compliance_result = "NOT_APPLICABLE"
                else:
                    return build_internal_error_response(
                        "Unexpected message type", str(invoking_event)
                    )
            except botocore.exceptions.ClientError as ex:
                if is_internal_error(ex):
                    return build_internal_error_response(
                        "Unexpected error while completing API request", str(ex)
                    )
                return build_error_response(
                    "Customer error while making API request",
                    str(ex),
                    ex.response["Error"]["Code"],
                    ex.response["Error"]["Message"],
                )
            except ValueError as ex:
                return build_internal_error_response(str(ex), str(ex))


            evaluations = []
            latest_evaluations = []


            if not compliance_result:
                latest_evaluations.append(
                    build_evaluation(
                        event["accountId"],
                        "NOT_APPLICABLE",
                        event,
                        resource_type="AWS::::Account",
                    )
                )
                evaluations = clean_up_old_evaluations(latest_evaluations, event)
            elif isinstance(compliance_result, str):
                if configuration_item:
                    evaluations.append(
                        build_evaluation_from_config_item(configuration_item, compliance_result)
                    )
                else:
                    evaluations.append(
                        build_evaluation(
                            event["accountId"],
                            compliance_result,
                            event,
                            resource_type=DEFAULT_RESOURCE_TYPE,
                        )
                    )
            elif isinstance(compliance_result, list):
                for evaluation in compliance_result:
                    missing_fields = False
                    for field in (
                        "ComplianceResourceType",
                        "ComplianceResourceId",
                        "ComplianceType",
                        "OrderingTimestamp",
                    ):
                        if field not in evaluation:
                            print("Missing " + field + " from custom evaluation.")
                            missing_fields = True


                    if not missing_fields:
                        latest_evaluations.append(evaluation)
                evaluations = clean_up_old_evaluations(latest_evaluations, event)
            elif isinstance(compliance_result, dict):
                missing_fields = False
                for field in (
                    "ComplianceResourceType",
                    "ComplianceResourceId",
                    "ComplianceType",
                    "OrderingTimestamp",
                ):
                    if field not in compliance_result:
                        print("Missing " + field + " from custom evaluation.")
                        missing_fields = True
                if not missing_fields:
                    evaluations.append(compliance_result)
            else:
                evaluations.append(
                    build_evaluation_from_config_item(configuration_item, "NOT_APPLICABLE")
                )


            # Put together the request that reports the evaluation status
            rt = event["resultToken"]
            test_mode = False
            if rt == "TESTMODE":

                # Used solely for RDK test to skip actual put_evaluation API call
                test_mode = True


            # Invoke the Config API to report the result of the evaluation
            evaluation_copy = []
            evaluation_copy = evaluations[:]
            while evaluation_copy:
                AWS_CONFIG_CLIENT.put_evaluations(
                    Evaluations=evaluation_copy[:100],
                    ResultToken=rt,
                    TestMode=test_mode,
                )
                del evaluation_copy[:100]


            # Used solely for RDK test to be able to test Lambda function
            return evaluations




        def is_internal_error(exception):
            return (
                (not isinstance(exception, botocore.exceptions.ClientError))
                or exception.response["Error"]["Code"].startswith("5")
                or "InternalError" in exception.response["Error"]["Code"]
                or "ServiceError" in exception.response["Error"]["Code"]
            )




        def build_internal_error_response(internal_error_message, internal_error_details=None):
            return build_error_response(
                internal_error_message, internal_error_details, "InternalError", "InternalError"
            )




        def build_error_response(
            internal_error_message,
            internal_error_details=None,
            customer_error_code=None,
            customer_error_message=None,
        ):
            error_response = {
                "internalErrorMessage": internal_error_message,
                "internalErrorDetails": internal_error_details,
                "customerErrorMessage": customer_error_message,
                "customerErrorCode": customer_error_code,
            }
            print(error_response)
            return error_response




        def ebs_gp3_evaluate_compliance(configuration_item, valid_rule_parameters):
            if configuration_item["resourceType"] != "AWS::EC2::Volume" or (
                configuration_item["configuration"]["volumeType"] != "gp2"
            ):
                return "NOT_APPLICABLE"


            if (
                configuration_item["configuration"]["volumeType"]
                == valid_rule_parameters["desiredvolumeType"]
            ):
                return "COMPLIANT"


            return "NON_COMPLIANT"




        def ec2_rightsizing_evaluate_compliance(configuration_item, valid_rule_parameters):
            if configuration_item["resourceType"] != "AWS::EC2::Instance":
                return "NOT_APPLICABLE"


            # pylint: disable=undefined-variable
            # boto3 library is already imported in Lambda code.
            recommendations = boto3.client("ce").get_rightsizing_recommendation(
                Configuration={
                    "RecommendationTarget": "CROSS_INSTANCE_FAMILY",
                    "BenefitsConsidered": True,
                },
                Service="AmazonEC2",
            )
            target_instances = [
                r["ModifyRecommendationDetail"]["TargetInstances"]
                for r in recommendations["RightsizingRecommendations"]
                if r["CurrentInstance"]["ResourceId"] == configuration_item["resourceId"]
            ]
            if len(target_instances) > 0:
                for s in target_instances[0]:
                    if (
                        "EstimatedMonthlySavings" in s
                        and float(s["EstimatedMonthlySavings"]) > 0
                    ):
                        return "NON_COMPLIANT"


            return "COMPLIANT"

  CustomConfigFunctionPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      Principal: config.amazonaws.com
      FunctionName: !GetAtt CustomConfigFunction.Arn

  StackSet:
    Type: AWS::CloudFormation::StackSet
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
    Properties:
      StackSetName: !Sub ${AWS::StackName}-StackSet
      PermissionModel: SERVICE_MANAGED
      StackInstancesGroup:
        - DeploymentTargets:
            OrganizationalUnitIds:
              - !Ref OrgDetails
          Regions:
            - !Ref AWS::Region
      AutoDeployment:
        Enabled: true
        RetainStacksOnAccountRemoval: false
      ManagedExecution:
        Active: true
      OperationPreferences:
        MaxConcurrentPercentage: 100
        FailureTolerancePercentage: 100
        RegionConcurrencyType: PARALLEL
      Capabilities:
        - CAPABILITY_IAM
        - CAPABILITY_NAMED_IAM
      Parameters:
        - ParameterKey: RuleFunctionRoleArn
          ParameterValue: !GetAtt CustomConfigFunctionRole.Arn
        - ParameterKey: ConfigRoleExistingNamePattern
          ParameterValue: !Ref ConfigRoleExistingNamePattern
      CallAs: !If
        - DelegatedAdmin
        - DELEGATED_ADMIN
        - SELF
      TemplateBody: |-
        AWSTemplateFormatVersion: "2010-09-09"


        Parameters:
          RuleFunctionRoleArn:
            Type: String


          ConfigRoleExistingNamePattern:
            Type: String


        Resources:
          AutomationRole:
            Type: AWS::IAM::Role
            Metadata:
              cfn_nag:
                rules_to_suppress:
                  - id: W28
                    reason: Hardcoded name required for Conformance Pack.
            Properties:
              RoleName: !Sub CostOpt-Automation-${AWS::Region}
              AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: Allow
                    Principal:
                      Service: ssm.amazonaws.com
                    Action: sts:AssumeRole
              Policies:
                - PolicyName: EC2ModifyVolume
                  PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Effect: Allow
                        Action: ec2:ModifyVolume
                        Resource:
                          - !Sub "arn:${AWS::Partition}:ec2:${AWS::Region}:${AWS::AccountId}:volume/*"


          CrossAccountRole:
            Type: AWS::IAM::Role
            Metadata:
              cfn_nag:
                rules_to_suppress:
                  - id: W28
                    reason: Hardcoded name required for Conformance Pack.
            Properties:
              RoleName: !Sub Custom_AWSServiceRoleForConfig-${AWS::Region}
              AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: Allow
                    Principal:
                      Service: config.amazonaws.com
                      AWS:
                        - !Ref RuleFunctionRoleArn
                    Action: sts:AssumeRole
              ManagedPolicyArns:
                - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWS_ConfigRole


          ConfigureConfigFunctionRole:
            Type: AWS::IAM::Role
            Metadata:
              cfn_nag:
                rules_to_suppress:
                  - id: W11
                    reason: Resource level permissions not possible on these APIs.
            Properties:
              AssumeRolePolicyDocument:
                Version: "2012-10-17"
                Statement:
                  - Effect: Allow
                    Principal:
                      Service: lambda.amazonaws.com
                    Action: sts:AssumeRole
              ManagedPolicyArns:
                - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
              Policies:
                - PolicyName: ConfigureConfig
                  PolicyDocument:
                    Version: "2012-10-17"
                    Statement:
                      - Effect: Allow
                        Action:
                          - config:DescribeConfigurationRecorders
                          - config:PutConfigurationRecorder
                        Resource: '*'
                      - Effect: Allow
                        Action:
                          - iam:PassRole
                        Resource:
                          - !GetAtt CrossAccountRole.Arn
                          - !Sub "arn:${AWS::Partition}:iam::${AWS::AccountId}:role/${ConfigRoleExistingNamePattern}"


          ConfigureConfigFunction:
            Type: AWS::Lambda::Function
            Metadata:
              cfn-lint:
                config:
                  ignore_checks:
                    - E3002 # Need to ignore cfn-lint illegal function check due to usage of !Rain::Embed
              cfn_nag:
                rules_to_suppress:
                  - id: W89
                    reason: VPC not required.
                  - id: W92
                    reason: Reserved Concurrency not required.
                  - id: W58
                    reason: The managed policy AWSLambdaBasicExecutionRole gives the required CloudWatch Logs permissions.
            Properties:
              Runtime: python3.10
              Handler: index.handler
              Role: !GetAtt ConfigureConfigFunctionRole.Arn
              Architectures:
                - arm64
              Code:
                ZipFile: |-
                  import json




                  import boto3
                  import cfnresponse




                  cfg = boto3.client("config")








                  def get_configuration_recorder():
                      configuration_recorders = cfg.describe_configuration_recorders()[
                          "ConfigurationRecorders"
                      ]
                      if configuration_recorders:
                          return configuration_recorders[0]
                      else:
                          raise ValueError(
                              "AWS Config is not configured as required. Please review AWS Config to be sure is it is set up in this account and region."
                          )








                  def put_configuration_recorder(name, recording_group, role_arn):
                      cfg.put_configuration_recorder(
                          ConfigurationRecorder={
                              "name": name,
                              "recordingGroup": recording_group,
                              "roleARN": role_arn,
                          }
                      )








                  def handler(event, context):


                      # pylint: disable=unused-argument
                      print(json.dumps(event))
                      try:
                          configuration_recorder = get_configuration_recorder()
                          if event["RequestType"] in ["Create", "Update"]:
                              put_configuration_recorder(
                                  configuration_recorder["name"],
                                  configuration_recorder["recordingGroup"],
                                  event["ResourceProperties"]["ConfigRoleArn"],
                              )
                              cfnresponse.send(
                                  event,
                                  context,
                                  cfnresponse.SUCCESS,
                                  None,
                                  configuration_recorder["roleARN"]
                                  if event["RequestType"] == "Create"
                                  else event["PhysicalResourceId"],
                              )
                          elif event["RequestType"] == "Delete":
                              if event["PhysicalResourceId"].startswith("arn:aws:iam"):
                                  put_configuration_recorder(
                                      configuration_recorder["name"],
                                      configuration_recorder["recordingGroup"],
                                      event["PhysicalResourceId"],
                                  )
                              cfnresponse.send(
                                  event, context, cfnresponse.SUCCESS, None, event["PhysicalResourceId"]
                              )
                      except Exception:
                          cfnresponse.send(event, context, cfnresponse.FAILED, None, "Config")
                          raise


          ConfigureConfig:
            Type: Custom::OrganizationRootId
            Properties:
              ServiceToken: !GetAtt ConfigureConfigFunction.Arn
              ConfigRoleArn: !GetAtt CrossAccountRole.Arn

  ShareDocumentFunction:
    Type: AWS::Serverless::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: VPC not required.
          - id: W92
            reason: Reserved Concurrency not required.
          - id: W11
            reason: Resource level permissions not possible on this API.
    Properties:
      Runtime: python3.10
      Handler: index.handler
      Architectures:
        - arm64
      Policies:
        - Version: "2012-10-17"
          Statement:
            - Effect: Allow
              Action:
                - organizations:ListAccounts
              Resource: '*'
            - Effect: Allow
              Action:
                - ssm:ModifyDocumentPermission
              Resource: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/${AWS::StackName}-*Remediation-*
      InlineCode: |-
        import json


        import boto3
        import cfnresponse


        ssm = boto3.client("ssm")




        def get_accounts(context):
            aws_account_id = context.invoked_function_arn.split(":")[4]
            org = boto3.client("organizations")
            list_accounts = org.list_accounts()
            accountids = [a["Id"] for a in list_accounts["Accounts"] if a["Status"] == "ACTIVE"]
            while "NextToken" in list_accounts:
                list_accounts = org.list_accounts(NextToken=list_accounts["NextToken"])
                accountids += [
                    a["Id"] for a in list_accounts["Accounts"] if a["Status"] == "ACTIVE"
                ]
            accountids.remove(aws_account_id)
            return accountids




        def share(context, document_name):
            accounts = get_accounts(context)
            for batch in range(0, len(accounts), 20):
                ssm.modify_document_permission(
                    Name=document_name,
                    PermissionType="Share",
                    AccountIdsToAdd=accounts[batch : batch + 20],
                )




        def unshare(context, document_name):
            accounts = get_accounts(context)
            for batch in range(0, len(accounts), 20):
                ssm.modify_document_permission(
                    Name=document_name,
                    PermissionType="Share",
                    AccountIdsToRemove=accounts[batch : batch + 20],
                )




        def handler(event, context):
            print(json.dumps(event))
            try:
                if event["RequestType"] == "Create":
                    share(context, event["ResourceProperties"]["DocumentName"])
                elif event["RequestType"] == "Update":
                    unshare(context, event["OldResourceProperties"]["DocumentName"])
                    share(context, event["ResourceProperties"]["DocumentName"])
                elif event["RequestType"] == "Delete":
                    unshare(context, event["ResourceProperties"]["DocumentName"])
                cfnresponse.send(event, context, cfnresponse.SUCCESS, None, "ShareDocument")
            except Exception:
                cfnresponse.send(event, context, cfnresponse.FAILED, None, "ShareDocument")
                raise

  ConformancePack:
    Type: AWS::Config::OrganizationConformancePack
    DependsOn: StackSet
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
    Properties:
      OrganizationConformancePackName: Cost-Optimization
      ExcludedAccounts:
        - !GetAtt OrgDetails.MasterAccountId
      ConformancePackInputParameters:
        - ParameterName: CustomConfigFunctionArn
          ParameterValue: !GetAtt CustomConfigFunction.Arn
        - ParameterName: EbsGp3DocumentArn
          ParameterValue: !Sub arn:${AWS::Partition}:ssm:${AWS::Region}:${AWS::AccountId}:document/${EbsGp3Remediation}
      TemplateBody: |-
        Parameters:
          CustomConfigFunctionArn:
            Type: String
          EbsGp3DocumentArn:
            Type: String
        Resources:
          EbsGp3Remediation:
            Type: AWS::Config::RemediationConfiguration
            Properties:
              ConfigRuleName: CostOpt-Ebs-Gp3
              ResourceType: AWS::EC2::Volume
              TargetType: SSM_DOCUMENT
              TargetId:
                Ref: EbsGp3DocumentArn
              Parameters:
                volumeid:
                  ResourceValue:
                    Value: RESOURCE_ID
              ExecutionControls:
                SsmControls:
                  ConcurrentExecutionRatePercentage: 10
                  ErrorPercentage: 10
              Automatic: false
              MaximumAutomaticAttempts: 10
              RetryAttemptSeconds: 600
          EbsGp3Rule:
            Type: AWS::Config::ConfigRule
            Properties:
              Scope:
                ComplianceResourceTypes:
                  - AWS::EC2::Volume
              Source:
                Owner: CUSTOM_LAMBDA
                SourceDetails:
                  - EventSource: aws.config
                    MessageType: ConfigurationItemChangeNotification
                SourceIdentifier:
                  Ref: CustomConfigFunctionArn
              InputParameters:
                desiredvolumeType: gp3
                customFunctionPrefix: ebs_gp3
              ConfigRuleName: CostOpt-Ebs-Gp3
          Ec2RightsizingRule:
            Type: AWS::Config::ConfigRule
            Properties:
              Scope:
                ComplianceResourceTypes:
                  - AWS::EC2::Volume
              Source:
                Owner: CUSTOM_LAMBDA
                SourceDetails:
                  - EventSource: aws.config
                    MessageType: ConfigurationItemChangeNotification
                SourceIdentifier:
                  Ref: CustomConfigFunctionArn
              ConfigRuleName: CostOpt-Ec2-Rightsizing
              InputParameters:
                customFunctionPrefix: ec2_rightsizing

  EbsGp3Remediation:
    Type: AWS::SSM::Document
    Properties:
      Content:
        schemaVersion: "0.3"
        assumeRole: arn:{{ global:AWS_PARTITION }}:iam::{{ global:ACCOUNT_ID }}:role/CostOpt-Automation-{{ global:REGION }}
        parameters:
          volumeid:
            type: String
        mainSteps:
          - name: ModifyVolume
            action: aws:executeAwsApi
            outputs:
              - Name: Output
                Selector: $
                Type: StringMap
            inputs:
              Service: ec2
              Api: ModifyVolume
              VolumeId: '{{ volumeid }}'
              VolumeType: gp3
        outputs:
          - ModifyVolume.Output
      DocumentFormat: YAML
      DocumentType: Automation

  EbsGp3RemediationShare:
    Type: Custom::ShareDocument
    Properties:
      DocumentName: !Ref EbsGp3Remediation
      ServiceToken: !GetAtt ShareDocumentFunction.Arn
